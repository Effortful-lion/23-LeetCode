

> LCR 024.反转链表
>
> 给定单链表的头节点head，请反转链表，并返回反转后的链表的头节点。



法一：迭代



![](https://lalala1502.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-05%20201523.png)

``struct ListNode {`

​        `int val;`

​		`struct ListNode *next;`

`};`

`struct ListNode* reverseList(struct ListNode* head) {`
    `struct ListNode* prev = NULL;//由于反转链表后的尾节点为反转前的头节点前NULL`
    `struct ListNode* now = head;`
    `while (now != NULL) {//`
        `struct ListNode* temp = now->next;`
        `now->next = prev;`
        `prev = now;`
        `now = temp;`
    `}`
    `return prev;//由于跳出while的条件是到达反转前链表尾处的空指针，故需返回其前一个节点`
`}`

法2：递归

``struct ListNode {`

​        `int val;`

​		`struct ListNode *next;`

`};`

`struct ListNode* reverseList(struct ListNode* head) {
    if (head == NULL || head->next == NULL)//写出回溯条件
        return head;
    struct ListNode* new = reverseList(head->next);//第一次回溯的返回值为尾节点后续回溯均为传递该值
    head->next->next = head;//head->next为head后一节点，为实现目标，需将后一节点指点前一节点。
    head->next = NULL;
    return new;
}`

